#!/usr/bin/env python

"""Benchmarks for Python's regex engine.

These are some of the original benchmarks used to tune Python's regex engine
in 2000 written by Fredrik Lundh. Retreived from
http://mail.python.org/pipermail/python-dev/2000-August/007797.html and
integrated into Unladen Swallow's perf.py in 2009 by David Laing.

These benchmarks are of interest since they helped to guide the original
optimization of the sre engine, and we shouldn't necessarily ignore them just
because they're "old".
"""

# Python imports
import optparse
import re
import time

# Local imports
import util
from compat import xrange

USE_BYTES_IN_PY3K = False

def re_compile(s):
    if USE_BYTES_IN_PY3K:
        return re.compile(s.encode('latin1'))
    else:
        return re.compile(s)

# These are the regular expressions to be tested. These sync up,
# index-for-index with the list of strings generated by gen_string_table()
# below.
def gen_regex_table():
    global regexs
    regexs = [
        re_compile('Python|Perl'),
        re_compile('Python|Perl'),
        re_compile('(Python|Perl)'),
        re_compile('(?:Python|Perl)'),
        re_compile('Python'),
        re_compile('Python'),
        re_compile('.*Python'),
        re_compile('.*Python.*'),
        re_compile('.*(Python)'),
        re_compile('.*(?:Python)'),
        re_compile('Python|Perl|Tcl'),
        re_compile('Python|Perl|Tcl'),
        re_compile('(Python|Perl|Tcl)'),
        re_compile('(?:Python|Perl|Tcl)'),
        re_compile('(Python)\\1'),
        re_compile('(Python)\\1'),
        re_compile('([0a-z][a-z0-9]*,)+'),
        re_compile('(?:[0a-z][a-z0-9]*,)+'),
        re_compile('([a-z][a-z0-9]*,)+'),
        re_compile('(?:[a-z][a-z0-9]*,)+'),
        re_compile('.*P.*y.*t.*h.*o.*n.*')]


def gen_string_table(n):
    """Generates the list of strings that will be used in the benchmarks.

    All strings have repeated prefixes and suffices, and n specifies the
    number of repetitions.
    """
    strings = []
    def append(s):
        if USE_BYTES_IN_PY3K:
            strings.append(s.encode('latin1'))
        else:
            strings.append(s)
    append('-'*n+'Perl'+'-'*n)
    append('P'*n+'Perl'+'P'*n)
    append('-'*n+'Perl'+'-'*n)
    append('-'*n+'Perl'+'-'*n)
    append('-'*n+'Python'+'-'*n)
    append('P'*n+'Python'+'P'*n)
    append('-'*n+'Python'+'-'*n)
    append('-'*n+'Python'+'-'*n)
    append('-'*n+'Python'+'-'*n)
    append('-'*n+'Python'+'-'*n)
    append('-'*n+'Perl'+'-'*n)
    append('P'*n+'Perl'+'P'*n)
    append('-'*n+'Perl'+'-'*n)
    append('-'*n+'Perl'+'-'*n)
    append('-'*n+'PythonPython'+'-'*n)
    append('P'*n+'PythonPython'+'P'*n)
    append('-'*n+'a5,b7,c9,'+'-'*n)
    append('-'*n+'a5,b7,c9,'+'-'*n)
    append('-'*n+'a5,b7,c9,'+'-'*n)
    append('-'*n+'a5,b7,c9,'+'-'*n)
    append('-'*n+'Python'+'-'*n)
    return strings

# A cache for the generated strings.
string_tables = {}

def init_benchmarks(n_values=None):
    """Initialize the strings we'll run the regexes against.

    The strings used in the benchmark are prefixed and suffixed by
    strings that are repeated n times.

    The sequence n_values contains the values for n.
    If n_values is None the values of n from the original benchmark
    are used.

    The generated list of strings is cached in the string_tables
    variable, which is indexed by n.

    Returns:
    A list of string prefix/suffix lengths.
    """
    if n_values is None:
        n_values = [0, 5, 50, 250, 1000, 5000, 10000]

    for n in n_values:
        string_tables[n] = gen_string_table(n)
    gen_regex_table()
    return n_values


def run_benchmarks(n):
    """Runs all of the benchmarks for a given value of n."""
    for id in xrange(len(regexs)):
        re.search(regexs[id], string_tables[n][id])
        re.search(regexs[id], string_tables[n][id])
        re.search(regexs[id], string_tables[n][id])
        re.search(regexs[id], string_tables[n][id])
        re.search(regexs[id], string_tables[n][id])
        re.search(regexs[id], string_tables[n][id])
        re.search(regexs[id], string_tables[n][id])
        re.search(regexs[id], string_tables[n][id])
        re.search(regexs[id], string_tables[n][id])
        re.search(regexs[id], string_tables[n][id])


def test_regex_effbot(iterations):
    sizes = init_benchmarks()

    # Warm up.
    for size in sizes:
        run_benchmarks(size)

    times = []
    for i in xrange(iterations):
        t0 = time.time()
        for size in sizes:
            run_benchmarks(size)
        t1 = time.time()
        times.append(t1 - t0)
    return times


if __name__ == '__main__':
    parser = optparse.OptionParser(
        usage="%prog [options]",
        description=("Test the performance of regexps using Fredik Lundh's "
                     "benchmarks."))
    parser.add_option("-B", "--force_bytes", action="store_true",
                      help="Force testing bytes regexps under 3.x.")
    util.add_standard_options_to(parser)
    options, args = parser.parse_args()

    if options.force_bytes:
        globals()['USE_BYTES_IN_PY3K'] = True
    util.run_benchmark(options, options.num_runs, test_regex_effbot)
